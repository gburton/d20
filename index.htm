<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bunting Mental - Doubles Practice</title>
<link href="board.css" rel="stylesheet">
</head>
<body>

<h1>Bunting Mental - Doubles Practice</h1>

<div class="container">
  <div class="panel">
    <ul class="stats-list" id="results"></ul>
    <div class="totals" id="totals">Total hits: 0</div>
    <br>
    <button class="btn btn-secondary" id="clearStats">Clear Stats</button>
    <button class="btn btn-primary" id="exportStats">Export Stats</button>
  </div>

  <div class="panel board-container">
    <svg viewBox="-225 -225 450 450" id="dartboard"></svg>
  </div>

  <div class="panel">
    <div class="current-double" id="currentDoubleDisplay">
      <div class="current-double-text" id="currentDoubleText">-</div>
    </div>
    
    <h3>Enter Hits</h3>
    <div class="input-group">
      <input type="number" id="hits" min="0" max="15" placeholder="0-15">
      <button class="btn btn-primary" id="submit">Submit Round</button>
    </div>
  </div>
</div>

<script>
class DartboardApp {
  constructor() {
    // Constants
    this.NUMBERS = [20,1,18,4,13,6,10,15,2,17,3,19,7,16,8,11,14,9,12,5];
    this.ALL_DOUBLES = [...Array(20).keys()].map(i => i + 1).concat(25);
    this.STORAGE_KEYS = {
      remaining: 'remainingDoubles',
      current: 'currentDouble',
      sessions: 'doublesSessions'
    };
    
    // Board dimensions
    this.DIMS = {
      outerRadius: 200,
      doubleWidth: 20,
      trebleRadius: 120,
      trebleWidth: 20,
      bullOuter: 16,
      bullInner: 8
    };
    
    // State
    this.remaining = this.loadData(this.STORAGE_KEYS.remaining) || [...this.ALL_DOUBLES];
    this.currentDouble = this.loadData(this.STORAGE_KEYS.current);
    this.totalHits = 0;
    this.totalAttempts = 0;
    
    // DOM elements
    this.elements = {
      svg: document.getElementById('dartboard'),
      hits: document.getElementById('hits'),
      submit: document.getElementById('submit'),
      results: document.getElementById('results'),
      totals: document.getElementById('totals'),
      clear: document.getElementById('clearStats'),
      export: document.getElementById('exportStats'),
      currentDoubleText: document.getElementById('currentDoubleText'),
      currentDoubleDisplay: document.getElementById('currentDoubleDisplay')
    };
    
    this.init();
  }
  
  init() {
    this.bindEvents();
    this.drawBoard();
    this.renderStats();
    this.setupCurrentDouble();
    this.elements.hits.focus();
  }
  
  bindEvents() {
    this.elements.hits.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        this.submitRound();
        e.preventDefault();
      }
    });
    
    this.elements.hits.addEventListener('focus', () => this.elements.hits.select());
    this.elements.hits.addEventListener('blur', () => 
      setTimeout(() => this.elements.hits.focus(), 0));
    
    this.elements.submit.addEventListener('click', () => this.submitRound());
    this.elements.clear.addEventListener('click', () => this.clearStats());
    this.elements.export.addEventListener('click', () => this.exportStats());
  }
  
  getDoubleColor(doubleNum) {
    if (doubleNum === 25) {
      return 'red';
    }
    const idx = this.NUMBERS.indexOf(doubleNum);
    return (idx % 2 === 0) ? 'red' : 'green';
  }
  
  updateCurrentDoubleDisplay() {
    if (this.currentDouble !== null) {
      this.elements.currentDoubleText.textContent = `D${this.currentDouble}`;
      this.elements.currentDoubleDisplay.classList.remove('green');
      const color = this.getDoubleColor(this.currentDouble);
      if (color === 'green') {
        this.elements.currentDoubleDisplay.classList.add('green');
      }
    } else {
      this.elements.currentDoubleText.textContent = '-';
      this.elements.currentDoubleDisplay.classList.remove('green');
    }
  }
  
  loadData(key) {
    try {
      const data = localStorage.getItem(key);
      return data ? JSON.parse(data) : null;
    } catch {
      return null;
    }
  }
  
  saveData(key, data) {
    try {
      if (data === null) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(data));
      }
    } catch (e) {
      console.warn('Failed to save data:', e);
    }
  }
  
  saveSession(hits) {
    const sessions = this.loadData(this.STORAGE_KEYS.sessions) || [];
    const session = {
        date: new Date().toISOString(),
        double: this.currentDouble,
        hits: hits,
        timestamp: Date.now()
    };
    sessions.push(session);
    this.saveData(this.STORAGE_KEYS.sessions, sessions);
    return session;
  }

  getSessionStats() {
    const sessions = this.loadData(this.STORAGE_KEYS.sessions) || [];
    const stats = {};
    
    this.ALL_DOUBLES.forEach(dbl => {
        stats[dbl] = { attempts: 0, totalHits: 0, sessions: [] };
    });

    sessions.forEach(session => {
        const dbl = session.double;
        if (stats[dbl]) {
            stats[dbl].attempts++;
            stats[dbl].totalHits += session.hits;
            stats[dbl].sessions.push(session);
        }
    });

    return { stats, sessions };
  }

  polarToCartesian(cx, cy, r, angleDeg) {
    const angleRad = (angleDeg - 90) * Math.PI / 180;
    return {
      x: cx + r * Math.cos(angleRad),
      y: cy + r * Math.sin(angleRad)
    };
  }
  
  createArcPath(cx, cy, rInner, rOuter, startAngle, endAngle) {
    const startOuter = this.polarToCartesian(cx, cy, rOuter, endAngle);
    const endOuter = this.polarToCartesian(cx, cy, rOuter, startAngle);
    const startInner = this.polarToCartesian(cx, cy, rInner, startAngle);
    const endInner = this.polarToCartesian(cx, cy, rInner, endAngle);
    const largeArc = endAngle - startAngle <= 180 ? 0 : 1;
    
    return [
      'M', startOuter.x, startOuter.y,
      'A', rOuter, rOuter, 0, largeArc, 0, endOuter.x, endOuter.y,
      'L', startInner.x, startInner.y,
      'A', rInner, rInner, 0, largeArc, 1, endInner.x, endInner.y,
      'Z'
    ].join(' ');
  }
  
  createElement(type, attrs = {}) {
    const el = document.createElementNS('http://www.w3.org/2000/svg', type);
    Object.entries(attrs).forEach(([key, value]) => el.setAttribute(key, value));
    return el;
  }
  
  drawBoard() {
    const svg = this.elements.svg;
    const { NUMBERS, DIMS } = this;
    const { outerRadius, doubleWidth, trebleRadius, trebleWidth, bullOuter, bullInner } = DIMS;
    
    svg.innerHTML = '';
    
    for (let i = 0; i < 20; i++) {
      const startAngle = -9 + i * 18;
      const endAngle = -9 + (i + 1) * 18;
      const isEven = i % 2 === 0;
      const singleColor = isEven ? '#000' : '#fff';
      const specialColor = isEven ? '#dc3545' : '#28a745';
      
      const doublePath = this.createElement('path', {
        d: this.createArcPath(0, 0, outerRadius - doubleWidth, outerRadius, startAngle, endAngle),
        fill: specialColor,
        id: `double${NUMBERS[i]}`,
        class: 'segment'
      });
      svg.appendChild(doublePath);
      
      svg.appendChild(this.createElement('path', {
        d: this.createArcPath(0, 0, trebleRadius - trebleWidth, trebleRadius, startAngle, endAngle),
        fill: specialColor,
        class: 'segment'
      }));
      
      svg.appendChild(this.createElement('path', {
        d: this.createArcPath(0, 0, trebleRadius, outerRadius - doubleWidth, startAngle, endAngle),
        fill: singleColor,
        class: 'segment'
      }));
      
      svg.appendChild(this.createElement('path', {
        d: this.createArcPath(0, 0, bullOuter, trebleRadius - trebleWidth, startAngle, endAngle),
        fill: singleColor,
        class: 'segment'
      }));
      
      const angleMid = (startAngle + endAngle) / 2;
      const pos = this.polarToCartesian(0, 0, outerRadius + 15, angleMid);
      const numberText = this.createElement('text', {
        x: pos.x,
        y: pos.y,
        class: 'number'
      });
      numberText.textContent = NUMBERS[i];
      svg.appendChild(numberText);
    }
    
    svg.appendChild(this.createElement('circle', {
      r: bullOuter,
      fill: '#28a745'
    }));
    
    svg.appendChild(this.createElement('circle', {
      r: bullInner,
      fill: '#dc3545',
      id: 'double25'
    }));
  }
  
  setupCurrentDouble() {
    if (this.currentDouble !== null) {
      this.highlightDouble(this.currentDouble);
      this.updateCurrentDoubleDisplay();
    } else {
      this.pickRandomDouble();
    }
  }
  
  pickRandomDouble() {
    if (this.remaining.length === 0) {
      this.handleRoundComplete();
      return;
    }
    
    const idx = Math.floor(Math.random() * this.remaining.length);
    this.currentDouble = this.remaining.splice(idx, 1)[0];
    this.saveData(this.STORAGE_KEYS.remaining, this.remaining);
    this.saveData(this.STORAGE_KEYS.current, this.currentDouble);
    
    this.clearHighlights();
    this.highlightDouble(this.currentDouble);
    this.updateCurrentDoubleDisplay();
    this.elements.hits.focus();
  }
  
  handleRoundComplete() {
    this.elements.submit.disabled = true;
    this.elements.hits.disabled = true;
    this.clearHighlights();
    this.elements.currentDoubleText.textContent = '-';
    this.elements.currentDoubleDisplay.classList.remove('green');
    
    setTimeout(() => {
      alert('All doubles completed!');
      this.resetRound();
    }, 0);
  }
  
  resetRound() {
    this.remaining = [...this.ALL_DOUBLES];
    this.currentDouble = null;
    this.saveData(this.STORAGE_KEYS.remaining, this.remaining);
    this.saveData(this.STORAGE_KEYS.current, null);
    
    this.elements.submit.disabled = false;
    this.elements.hits.disabled = false;
    this.pickRandomDouble();
  }
  
  highlightDouble(doubleNum) {
    const el = document.getElementById(`double${doubleNum}`);
    if (el) el.setAttribute('fill', '#ffd700');
  }
  
  clearHighlights() {
    this.ALL_DOUBLES.forEach(dbl => {
      const el = document.getElementById(`double${dbl}`);
      if (el) {
        if (dbl === 25) {
          el.setAttribute('fill', '#dc3545');
        } else {
          const idx = this.NUMBERS.indexOf(dbl);
          const isEven = idx % 2 === 0;
          el.setAttribute('fill', isEven ? '#dc3545' : '#28a745');
        }
      }
    });
  }
  
  submitRound() {
    if (this.currentDouble === null) return;
    
    const hits = parseInt(this.elements.hits.value, 10);
    if (isNaN(hits) || hits < 0 || hits > 15) {
      alert('Enter valid hits (0-15)');
      return;
    }
    
    this.saveSession(hits);
    this.renderStats();
    this.pickRandomDouble();
    this.elements.hits.select();
  }
  
  renderStats() {
    const { stats } = this.getSessionStats();
    const fragment = document.createDocumentFragment();
    this.totalHits = 0;
    this.totalAttempts = 0;

    this.ALL_DOUBLES.forEach(dbl => {
      const data = stats[dbl];
      const li = document.createElement('li');
      li.className = 'stats-item';

      let colorClass;
      if(dbl === 25) colorClass = 'badge-red';
      else {
        const idx = this.NUMBERS.indexOf(dbl);
        colorClass = (idx % 2 === 0) ? 'badge-red' : 'badge-green';
      }

      const badge = document.createElement('span');
      badge.className = `badge ${colorClass}`;
      badge.textContent = `D${dbl}`;
      li.appendChild(badge);

      const text = document.createElement('span');
      if (data && data.attempts > 0) {
        this.totalHits += data.totalHits;
        this.totalAttempts += data.attempts;
        const avg = (data.totalHits / data.attempts).toFixed(2);
        text.textContent = `${data.totalHits} hits in ${data.attempts} rounds (avg: ${avg})`;
      } else {
        text.textContent = 'No data yet';
        text.style.color = '#999';
      }
      li.appendChild(text);
      fragment.appendChild(li);
    });

    this.elements.results.innerHTML = '';
    this.elements.results.appendChild(fragment);
    this.elements.totals.textContent = `Total hits: ${this.totalHits} (${this.totalAttempts} attempts)`;
  }
  
  clearStats() {
    if (!confirm('Clear all statistics and start fresh?')) return;
    
    Object.values(this.STORAGE_KEYS).forEach(key => 
      this.saveData(key, null));
    
    this.remaining = [...this.ALL_DOUBLES];
    this.currentDouble = null;
    this.renderStats();
    this.clearHighlights();
    this.pickRandomDouble();
  }
  
  exportStats() {
    const { stats } = this.getSessionStats();
    let exportText = 'Doubles Practice Statistics\n';
    exportText += '============================\n\n';
    
    const orderedDoubles = [...Array(20).keys()].map(i => i + 1).concat(25);
    
    orderedDoubles.forEach(dbl => {
      const data = stats[dbl];
      if (data && data.attempts > 0) {
        const avg = (data.totalHits / data.attempts).toFixed(2);
        exportText += `[D${dbl}] ${data.totalHits} hits in ${data.attempts} rounds (avg: ${avg})\n`;
      } else {
        exportText += `[D${dbl}] No data yet\n`;
      }
    });
    
    exportText += `\nTotal hits: ${this.totalHits} (${this.totalAttempts} attempts)`;
    
    const blob = new Blob([exportText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `doubles-practice-stats-${new Date().toISOString().slice(0, 10)}.txt`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }
}

// Initialize app
new DartboardApp();
</script>

</body>
</html>